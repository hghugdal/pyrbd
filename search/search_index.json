{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"pyRBD","text":"<p>A Python package for creating simple reliability block diagrams (RBDs) using <code>LaTeX</code> and <code>TikZ</code>.</p>"},{"location":"index.html#dependencies","title":"Dependencies","text":"<p><code>pyRBD</code> requires a working installation of <code>LaTeX</code> including <code>TikZ</code> and <code>latexmk</code>.</p>"},{"location":"index.html#simple-example-diagram","title":"Simple example diagram","text":"<p>The blocks of the RBD are defined using <code>Block</code>, <code>Series</code> and <code>Group</code>, and the diagram itself is handled by the <code>Diagram</code> class. A simple example is given by the code</p> <pre><code>from pyrbd import Block, Diagram\n\nstart_block = Block(\"Start\", \"blue!30\", parent=None)\nparallel = 2 * Block(\"Parallel blocks\", \"gray\", parent=start_block)\nend_block = Block(\"End\", \"green!50\", parent=parallel)\n\ndiagram = Diagram(\n    \"simple_RBD\",\n    blocks=[start_block, parallel, end_block],\n)\ndiagram.write()\ndiagram.compile()\n</code></pre> <p>producing the following diagram</p>"},{"location":"tutorials.html","title":"Tutorials","text":""},{"location":"tutorials.html#simple-diagram","title":"Simple diagram","text":"<pre><code>from pyrbd import Block, Diagram\n\n# Define the blocks comprising the diagram\nstart_block = Block(\"Start\", \"blue!30\")  # (1)\nparallel = 2 * Block(\"Parallel blocks\", \"gray\", parent=start_block)  # (2)\nend_block = Block(\"End\", \"green!50\", parent=parallel)  # (3)\n\n# Define and compile the diagram\ndiagram = Diagram(\n    \"simple_RBD\",\n    blocks=[start_block, parallel, end_block],\n)\ndiagram.write()\ndiagram.compile([\"pdf\", \"svg\"])  # (4)\n</code></pre> <ol> <li>The first block does not need a parent</li> <li>To get identical parallel blocks, multiply a <code>Block</code> instance by an <code>int</code></li> <li>For the other blocks we must specify the previous block in the diagram as the parent block</li> <li>We can specify multiple output formats by providing a list of formats.     Defaults to PDF if unspecified.</li> </ol>"},{"location":"tutorials.html#example-with-more-functionality","title":"Example with more functionality","text":"<pre><code>from pyrbd import Block, Group, Series, Diagram, config\n\nconfig.ARROW_STYLE = \"-latex\"  # (1)\nconfig.SERIF_FONT = True\n\n# Define all the blocks in the diagram\nstart_block = Block(\"Start\", \"myblue\", parent=None)\nparallel = 2 * Block(\"Parallel blocks\", \"gray\", parent=start_block)  # (2)\nblock_1 = Block(r\"Block 1\", \"yellow!50\")\nblock_2 = Block(r\"Block 2\", \"yellow!50\")\nblock_3 = Block(r\"Block 3\", \"yellow!50\")\nblock_4 = Block(r\"Block 4\", \"yellow!50\")\ngroup = Group(  # (3)\n    [block_1 + block_2, block_3 + block_4],  # (4)\n    parent=parallel,\n    text=\"Group\",\n    color=\"yellow\",\n)\nblock_a = Block(r\"Block A\", \"orange!50\")\nblock_b = Block(r\"Block B\", \"orange!50\")\nseries = Series([block_a, block_b], \"Series\", \"orange\", parent=group)  # (5)\nend_block = Block(\"End\", \"green!50\", parent=series)\n\n# Add blocks to Diagram class instance and compile diagram\ndiag = Diagram(\n    \"example_RBD\",\n    blocks=[start_block, parallel, group, series, end_block],\n    hazard=\"Hazard\",\n    colors={\"myblue\": \"8888ff\"},  # (6)\n)\ndiag.write()\ndiag.compile([\"svg\", \"png\"])\n</code></pre> <ol> <li>The arrow style and font can be set by changing the value of     <code>config.ARROW_STYLE</code> and <code>config.SERIF_FONT</code></li> <li>Here, a <code>Group</code> block is made by simply multiplying a <code>Block</code> instance by an integer</li> <li>To group different blocks vertically and set a title and color, use the <code>Group</code> class</li> <li>Adding <code>Block</code> instances creates a <code>Series</code> instance</li> <li>To group different blocks horizontally and set a title and color, use the <code>Series</code> class</li> </ol>"},{"location":"tutorials.html#layered-series-and-group-instances","title":"Layered <code>Series</code> and <code>Group</code> instances","text":"<pre><code>from pyrbd import Block, Group, Series, Diagram\n\n# Define the blocks comprising the diagram\nstart_block = Block(\"Start\", \"blue!30\")\nblock = Block(\"Block\", \"gray!20\")\ngroup_1 = Group(\n    [b * 2 for b in 3 * [block]],\n    text=\"Group with Series\",\n    color=\"orange\",\n    parent=start_block,\n)\nseries_1 = Series(\n    [deepcopy(block), 2 * block],\n    text=\"Series with Group\",\n    color=\"red\",\n    parent=group_1,\n)\nseries_2 = Series(\n    [2 * block, deepcopy(block), 3 * (block * 2)],\n    text=\"Series with mixed Groups\",\n    color=\"RoyalBlue\",\n    parent=series_1,\n)\ngroup_2 = Group(\n    [\n        block * 3,\n        deepcopy(block),\n        block * 4,\n    ],\n    text=\"Group with mixed Series\",\n    color=\"red\",\n    parent=series_2,\n)\nend_block = Block(\"End\", \"green!50\", parent=group_2)\n\n# Define and compile the diagram\ndiagram = Diagram(\n    \"layered_RBD\",\n    blocks=[start_block, group_1, series_1, series_2, group_2, end_block],\n)\ndiagram.write()\ndiagram.compile([\"pdf\", \"svg\"])\n</code></pre>"},{"location":"reference/index.html","title":"Reference","text":"<p>Creating diagrams with pyRBD is done in two steps:</p> <ol> <li>Defining the blocks of the diagram and the relationship between them.</li> <li>Adding blocks to the diagram and compiling the output diagram.</li> </ol> <p>The first step is done using the class <code>Block</code> or child classes <code>Series</code> and <code>Group</code>.</p> <p>The second step is done using <code>Diagram</code>.</p> <p>Global configuration options defined in the <code>config</code> module.</p>"},{"location":"reference/block.html","title":"Block","text":""},{"location":"reference/block.html#pyrbd.block","title":"<code>block</code>","text":"<p>Module containing Block, Series and Group class definitions.</p>"},{"location":"reference/block.html#pyrbd.block.Block","title":"<code>Block</code>","text":"<p>Block entering a reliability block diagram.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>block text string</p> required <code>color</code> <code>str</code> <p>block color</p> required <code>parent</code> <code>Optional[Block]</code> <p>parent <code>Block</code> instance</p> <code>None</code> <code>shift</code> <code>tuple[float, float]</code> <p>additional position shift <code>(x, y)</code> relative to <code>parent</code> <code>Block</code> instance</p> <code>(0.0, 0.0)</code> <p>Attributes:</p> Name Type Description <code>tikz_options</code> <code>str</code> <p>TikZ node formatting options</p> <code>arrow_options</code> <code>str</code> <p>TikZ arrow formatting options</p> <code>arrow_length</code> <code>float</code> <p>default arrow length between nodes (in cm)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; block_1 = Block(\"Start\", \"green\")\n&gt;&gt;&gt; block_1.id\n'1'\n&gt;&gt;&gt; block_2 = Block(\"End\", \"red\", parent=block_1)\n&gt;&gt;&gt; block_2.id\n'2'\n</code></pre> Source code in <code>pyrbd/block.py</code> <pre><code>class Block:\n    \"\"\"Block entering a reliability block diagram.\n\n    Parameters\n    ----------\n    text : str\n        block text string\n    color : str\n        block color\n    parent : Optional[Block]\n        parent `Block` instance\n    shift : tuple[float, float], default=(0.0, 0.0)\n        additional position shift `(x, y)` relative to `parent` `Block` instance\n\n    Attributes\n    ----------\n    tikz_options : str\n        TikZ node formatting options\n    arrow_options : str\n        TikZ arrow formatting options\n    arrow_length : float\n        default arrow length between nodes (in cm)\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; block_1 = Block(\"Start\", \"green\")\n    &gt;&gt;&gt; block_1.id\n    '1'\n    &gt;&gt;&gt; block_2 = Block(\"End\", \"red\", parent=block_1)\n    &gt;&gt;&gt; block_2.id\n    '2'\n    \"\"\"\n\n    tikz_options: str = \", \".join(\n        [\n            \"anchor=west\",\n            \"align=center\",\n            \"fill={fill_color}\",\n            \"draw=black!70!gray\",\n            \"minimum height=1cm\",\n            \"rounded corners=0.3mm\",\n            \"inner sep=4pt\",\n            \"outer sep=0pt\",\n        ]\n    )\n\n    arrow_options: str = \"arrowcolor, thick\"\n    arrow_length: float = 0.5\n\n    def __init__(\n        self,\n        text: str,\n        color: str,\n        parent: Optional[\"Block\"] = None,\n        shift: tuple[float, float] = (0.0, 0.0),\n    ) -&gt; None:\n        self.text = text\n        self.color = color\n        self.parent = parent\n        self.shift = shift\n        self.id: str = str(int(self.parent.id) + 1) if self.parent is not None else \"1\"\n\n    @property\n    def position(self) -&gt; str:\n        \"\"\"Block position TikZ string.\"\"\"\n\n        if self.parent is None:\n            return \"\"\n\n        return \" \".join(\n            [\n                f\"[right={self.arrow_length + self.shift[0]}cm\",\n                f\"of {self.parent.id},\",\n                f\"yshift={self.shift[1]}cm]\",\n            ]\n        )\n\n    def arrow(self, connector_position: float) -&gt; str:\n        \"\"\"Get TikZ arrow string.\n\n\n        Parameters\n        ----------\n        connector_position : float\n            distance in cm to right angle bend in connector\n\n        Returns\n        -------\n        str\n            TikZ string for arrow from `parent` to `self` or empty string if `parent` is `None`\n        \"\"\"\n\n        if self.parent is None:\n            return \"\"\n\n        return \"\".join(\n            [\n                f\"\\\\draw[{self.arrow_options}, rectangle connector={connector_position}cm]\",\n                f\"({self.parent.id}.east) to ({self.id}.west);\\n\\n\",\n            ]\n        )\n\n    def get_node(self, connector_position: Optional[float] = None) -&gt; str:\n        \"\"\"Get TikZ node string.\n\n        Parameters\n        ----------\n        connector_position : Optional[float]\n            distance in cm to right angle bend in connector. Defaults to `0.5*arrow_length`.\n\n        Returns\n        -------\n        str\n            TikZ string for rendering block\n        \"\"\"\n\n        if connector_position is None:\n            connector_position = self.arrow_length / 2\n\n        node = \"\".join(\n            [\n                \"% Block\\n\",\n                f\"\\\\node[{self.tikz_options.format(fill_color=self.color)}] \",\n                f\"({self.id}) \",\n                self.position,\n                f\"{{{self.text}}};\\n\",\n                self.arrow(connector_position),\n            ]\n        )\n        return node\n\n    def get_blocks(self) -&gt; Generator[\"Block\", None, None]:\n        \"\"\"Yield child `Block` istances.\"\"\"\n\n        yield self\n\n    def __add__(self, block: \"Block\") -&gt; \"Series\":\n        \"\"\"Add two `Block` instances to make a `Series` instance.\n\n        Parameters\n        ----------\n        block : Block\n            another `Block` instance\n\n        Returns\n        -------\n        Series\n            `Series` instance with `blocks = [self, block]`\n\n        Raises\n        ------\n        TypeError\n            If `block` is not an instance of `Block`\n        \"\"\"\n\n        if not isinstance(block, Block):\n            raise TypeError(\n                f\"cannot add object of type {type(block)=} to Block instance.\"\n            )\n\n        return Series([self, block], parent=self.parent)\n\n    def __rmul__(self, value: int) -&gt; \"Group\":\n        \"\"\"Right multiply `Block` instance by `value` to make `Group` with repeated blocks.\n\n        Parameters\n        ----------\n        value : int\n            multiplicative factor\n\n        Returns\n        -------\n        Group\n            `Group` instance with `value` copies of block\n\n        Raises\n        ------\n        ValueError\n            If `value` is not a positive integer\n        \"\"\"\n\n        if not isinstance(value, int) or value &lt;= 0:\n            raise ValueError(\"Multiplicative factor `value` must be a positive integer\")\n\n        blocks: list[Block] = [deepcopy(self) for _ in range(value)]\n\n        return Group(blocks, parent=self.parent)\n\n    def __mul__(self, value: int) -&gt; \"Series\":\n        \"\"\"Multiply `Block` instance by `value` to make `Series` with repeated blocks.\n\n        Parameters\n        ----------\n        value : int\n            multiplicative factor\n\n        Returns\n        -------\n        Series\n            `Series` instance with `value` copies of block\n\n        Raises\n        ------\n        ValueError\n            If `value` is not a positive integer\n        \"\"\"\n\n        if not isinstance(value, int) or value &lt;= 0:\n            raise ValueError(\"Multiplicative factor `value` must be a positive integer\")\n\n        blocks: list[Block] = [deepcopy(self) for _ in range(value)]\n\n        return Series(blocks, parent=self.parent)\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Block.position","title":"<code>position</code>  <code>property</code>","text":"<p>Block position TikZ string.</p>"},{"location":"reference/block.html#pyrbd.block.Block.__add__","title":"<code>__add__(block)</code>","text":"<p>Add two <code>Block</code> instances to make a <code>Series</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Block</code> <p>another <code>Block</code> instance</p> required <p>Returns:</p> Type Description <code>Series</code> <p><code>Series</code> instance with <code>blocks = [self, block]</code></p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>block</code> is not an instance of <code>Block</code></p> Source code in <code>pyrbd/block.py</code> <pre><code>def __add__(self, block: \"Block\") -&gt; \"Series\":\n    \"\"\"Add two `Block` instances to make a `Series` instance.\n\n    Parameters\n    ----------\n    block : Block\n        another `Block` instance\n\n    Returns\n    -------\n    Series\n        `Series` instance with `blocks = [self, block]`\n\n    Raises\n    ------\n    TypeError\n        If `block` is not an instance of `Block`\n    \"\"\"\n\n    if not isinstance(block, Block):\n        raise TypeError(\n            f\"cannot add object of type {type(block)=} to Block instance.\"\n        )\n\n    return Series([self, block], parent=self.parent)\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Block.__mul__","title":"<code>__mul__(value)</code>","text":"<p>Multiply <code>Block</code> instance by <code>value</code> to make <code>Series</code> with repeated blocks.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>multiplicative factor</p> required <p>Returns:</p> Type Description <code>Series</code> <p><code>Series</code> instance with <code>value</code> copies of block</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>value</code> is not a positive integer</p> Source code in <code>pyrbd/block.py</code> <pre><code>def __mul__(self, value: int) -&gt; \"Series\":\n    \"\"\"Multiply `Block` instance by `value` to make `Series` with repeated blocks.\n\n    Parameters\n    ----------\n    value : int\n        multiplicative factor\n\n    Returns\n    -------\n    Series\n        `Series` instance with `value` copies of block\n\n    Raises\n    ------\n    ValueError\n        If `value` is not a positive integer\n    \"\"\"\n\n    if not isinstance(value, int) or value &lt;= 0:\n        raise ValueError(\"Multiplicative factor `value` must be a positive integer\")\n\n    blocks: list[Block] = [deepcopy(self) for _ in range(value)]\n\n    return Series(blocks, parent=self.parent)\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Block.__rmul__","title":"<code>__rmul__(value)</code>","text":"<p>Right multiply <code>Block</code> instance by <code>value</code> to make <code>Group</code> with repeated blocks.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>multiplicative factor</p> required <p>Returns:</p> Type Description <code>Group</code> <p><code>Group</code> instance with <code>value</code> copies of block</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>value</code> is not a positive integer</p> Source code in <code>pyrbd/block.py</code> <pre><code>def __rmul__(self, value: int) -&gt; \"Group\":\n    \"\"\"Right multiply `Block` instance by `value` to make `Group` with repeated blocks.\n\n    Parameters\n    ----------\n    value : int\n        multiplicative factor\n\n    Returns\n    -------\n    Group\n        `Group` instance with `value` copies of block\n\n    Raises\n    ------\n    ValueError\n        If `value` is not a positive integer\n    \"\"\"\n\n    if not isinstance(value, int) or value &lt;= 0:\n        raise ValueError(\"Multiplicative factor `value` must be a positive integer\")\n\n    blocks: list[Block] = [deepcopy(self) for _ in range(value)]\n\n    return Group(blocks, parent=self.parent)\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Block.arrow","title":"<code>arrow(connector_position)</code>","text":"<p>Get TikZ arrow string.</p> <p>Parameters:</p> Name Type Description Default <code>connector_position</code> <code>float</code> <p>distance in cm to right angle bend in connector</p> required <p>Returns:</p> Type Description <code>str</code> <p>TikZ string for arrow from <code>parent</code> to <code>self</code> or empty string if <code>parent</code> is <code>None</code></p> Source code in <code>pyrbd/block.py</code> <pre><code>def arrow(self, connector_position: float) -&gt; str:\n    \"\"\"Get TikZ arrow string.\n\n\n    Parameters\n    ----------\n    connector_position : float\n        distance in cm to right angle bend in connector\n\n    Returns\n    -------\n    str\n        TikZ string for arrow from `parent` to `self` or empty string if `parent` is `None`\n    \"\"\"\n\n    if self.parent is None:\n        return \"\"\n\n    return \"\".join(\n        [\n            f\"\\\\draw[{self.arrow_options}, rectangle connector={connector_position}cm]\",\n            f\"({self.parent.id}.east) to ({self.id}.west);\\n\\n\",\n        ]\n    )\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Block.get_blocks","title":"<code>get_blocks()</code>","text":"<p>Yield child <code>Block</code> istances.</p> Source code in <code>pyrbd/block.py</code> <pre><code>def get_blocks(self) -&gt; Generator[\"Block\", None, None]:\n    \"\"\"Yield child `Block` istances.\"\"\"\n\n    yield self\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Block.get_node","title":"<code>get_node(connector_position=None)</code>","text":"<p>Get TikZ node string.</p> <p>Parameters:</p> Name Type Description Default <code>connector_position</code> <code>Optional[float]</code> <p>distance in cm to right angle bend in connector. Defaults to <code>0.5*arrow_length</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>TikZ string for rendering block</p> Source code in <code>pyrbd/block.py</code> <pre><code>def get_node(self, connector_position: Optional[float] = None) -&gt; str:\n    \"\"\"Get TikZ node string.\n\n    Parameters\n    ----------\n    connector_position : Optional[float]\n        distance in cm to right angle bend in connector. Defaults to `0.5*arrow_length`.\n\n    Returns\n    -------\n    str\n        TikZ string for rendering block\n    \"\"\"\n\n    if connector_position is None:\n        connector_position = self.arrow_length / 2\n\n    node = \"\".join(\n        [\n            \"% Block\\n\",\n            f\"\\\\node[{self.tikz_options.format(fill_color=self.color)}] \",\n            f\"({self.id}) \",\n            self.position,\n            f\"{{{self.text}}};\\n\",\n            self.arrow(connector_position),\n        ]\n    )\n    return node\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Group","title":"<code>Group</code>","text":"<p>               Bases: <code>Block</code></p> <p>Group of <code>Block</code> instances for vertical stacking.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>list[Block]</code> <p>list of <code>Block</code> instances</p> required <code>text</code> <code>str</code> <p>group label text</p> <code>\"\"</code> <code>color</code> <code>str</code> <p>group color, defaults to white</p> <code>\"\"</code> <code>parent</code> <code>Optional[Block]</code> <p>parent <code>Block</code> instance</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>shift_scale</code> <code>float</code> <p>scaling factor for vertical shifts of blocks</p> <code>tikz_options</code> <code>str</code> <p>TikZ node options</p> <code>internal_arrow_length</code> <code>float</code> <p>distance between blocks in series</p> <code>pad</code> <code>Padding</code> <p><code>namedtuple</code> <code>(north, east, south, west)</code> defining padding (in mmm) between blocks and series frame</p> <code>label_height</code> <code>float</code> <p>height of series label (in mm)</p> Source code in <code>pyrbd/block.py</code> <pre><code>class Group(Block):\n    \"\"\"Group of `Block` instances for vertical stacking.\n\n    Parameters\n    ----------\n    blocks : list[Block]\n        list of `Block` instances\n    text : str, default=\"\"\n        group label text\n    color : str, default=\"\"\n        group color, defaults to white\n    parent : Optional[Block]\n        parent `Block` instance\n\n    Attributes\n    ----------\n    shift_scale : float\n        scaling factor for vertical shifts of blocks\n    tikz_options : str\n        TikZ node options\n    internal_arrow_length : float\n        distance between blocks in series\n    pad : Padding\n        `namedtuple` `(north, east, south, west)` defining padding (in mmm) between\n        blocks and series frame\n    label_height : float\n        height of series label (in mm)\n    \"\"\"\n\n    shift_scale: float = 1.2\n    tikz_options: str = \", \".join(\n        [\n            \"anchor=west\",\n        ]\n    )\n    internal_arrow_length: float = 0.3\n    pad: Padding = Padding(1, 1, 1, 1)\n    label_height: float = 5.0\n\n    def __init__(\n        self,\n        blocks: list[Block],\n        text: str = \"\",\n        color: str = \"\",\n        parent: Optional[Block] = None,\n    ) -&gt; None:\n        Block.__init__(self, text, color, parent)\n\n        self.blocks = blocks\n        for i, (block, shift) in enumerate(zip(self.blocks, self.shifts)):\n            block.shift = (0, shift)\n            block.parent = self\n            block.id = f\"{self.id}-{i}\"\n            block.arrow_length = self.internal_arrow_length\n\n    @property\n    def shifts(self) -&gt; list[float]:\n        \"\"\"List of vertical position shifts for each `Block` instance in group.\n\n        Returns\n        -------\n        list[float]\n            list of vertical position shifts for each `Block` instance in group\n        \"\"\"\n\n        n_blocks = len(self.blocks)\n\n        return list(-self.shift_scale * n for n in range(n_blocks))\n\n    @property\n    def background(self) -&gt; str:\n        \"\"\"Background rectangle TikZ string.\"\"\"\n\n        if self.color in (\"white\", \"\"):\n            return \"\"\n\n        pad = self.pad\n\n        return \"\".join(\n            [\n                \"\\\\begin{pgfonlayer}{background}\\n\",\n                f\"\\\\coordinate (sw) at ($({self.id}.south west)+(-{pad.w}mm, -{pad.s}mm)$);\\n\",\n                f\"\\\\coordinate (ne) at ($({self.id}.north east)+({pad.e}mm, {pad.n}mm)$);\\n\",\n                f\"\\\\draw[{self.color}, thick] (sw) rectangle (ne);\\n\",\n                \"\\\\end{pgfonlayer}\\n\",\n            ]\n        )\n\n    @property\n    def label(self) -&gt; str:\n        \"\"\"Series label string.\"\"\"\n\n        if len(self.text) == 0:\n            return \"\"\n\n        pad = self.pad\n\n        return \"\".join(\n            [\n                f\"\\\\coordinate (nw) at ($({self.id}.north west)+(-{pad.w}mm, {pad.n}mm)$);\\n\",\n                f\"\\\\coordinate (ne) at ($({self.id}.north east)+({pad.e}mm, {pad.n}mm)$);\\n\",\n                \"\\\\coordinate (n) at \",\n                f\"($({self.id}.north)+(0mm, {self.label_height / 2 + pad.n}mm)$);\\n\",\n                f\"\\\\draw[{self.color}, fill={self.color}!50, thick] (nw) \",\n                f\"rectangle ($(ne)+(0, {self.label_height}mm)$);\\n\",\n                f\"\\\\node[anchor=center, inner sep=0pt, outer sep=0pt] at (n) {{{self.text}}};\\n\",\n            ]\n        )\n\n    def arrow(self, connector_position: float) -&gt; str:\n        \"\"\"Get TikZ arrow string.\n\n        Parameters\n        ----------\n        connector_position : float\n            distance in cm to right angle bend in connector (not used in `Group` class)\n\n        Returns\n        -------\n        str\n            TikZ string for arrow from `parent` to `self` or empty string if `parent` is `None`\n        \"\"\"\n\n        if self.parent is None:\n            return \"\"\n\n        return f\"\\\\draw[{self.arrow_options}] ({self.parent.id}.east) to ({self.id}.west);\\n\"\n\n    @property\n    def arrows(self) -&gt; str:\n        \"\"\"Get TikZ string for arrow connecting stacked blocks.\"\"\"\n\n        scaling = 0.75\n\n        series_blocks = [block for block in self.blocks if isinstance(block, Series)]\n        series_blocks.sort(\n            key=lambda block: len(list(block.get_blocks())), reverse=True\n        )\n\n        if len(series_blocks) &gt; 0:\n            longest_series_index = self.blocks.index(series_blocks[0])\n        else:\n            longest_series_index = 0\n        blocks = deepcopy(self.blocks)\n        longest_series = blocks.pop(longest_series_index)\n\n        return \"\\n\".join(\n            [\n                \" \".join(\n                    [\n                        f\"\\\\draw[{self.arrow_options},\",\n                        f\"rectangle line={scaling * self.internal_arrow_length}cm]\",\n                        f\"({longest_series.id}.east) to ({block.id}.east);\\n\",\n                    ]\n                )\n                for block in blocks\n            ]\n        )\n\n    def get_node(self, connector_position: Optional[float] = None) -&gt; str:\n        \"\"\"Get TikZ node string.\n\n        Parameters\n        ----------\n        connector_position : Optional[float]\n            distance in cm to right angle bend in connector.\n            Locked to 0.0 for `Group` class\n\n        Returns\n        -------\n        str\n            TikZ string for rendering group\n        \"\"\"\n\n        connector_position = 0.0\n\n        block_nodes = \"\\n\".join(\n            block.get_node(connector_position) for block in self.blocks\n        )\n\n        group_node = \"\".join(\n            [\n                \"%%% Group\\n\"\n                f\"\\\\node[anchor=west, outer sep=0pt, inner sep=0pt, align=center] ({self.id}) \",\n                self.position,\n                \"{\\\\begin{tikzpicture}\\n\",\n                f\"\\\\coordinate ({self.id}) at (0, 0);\\n\",\n                block_nodes,\n                self.arrows,\n                \"\\\\end{tikzpicture}};\\n\\n\",\n                self.arrow(connector_position),\n                self.background,\n                self.label,\n            ]\n        )\n\n        return group_node\n\n    def get_blocks(self) -&gt; Generator[Block, None, None]:\n        yield from self.blocks\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Group.arrows","title":"<code>arrows</code>  <code>property</code>","text":"<p>Get TikZ string for arrow connecting stacked blocks.</p>"},{"location":"reference/block.html#pyrbd.block.Group.background","title":"<code>background</code>  <code>property</code>","text":"<p>Background rectangle TikZ string.</p>"},{"location":"reference/block.html#pyrbd.block.Group.label","title":"<code>label</code>  <code>property</code>","text":"<p>Series label string.</p>"},{"location":"reference/block.html#pyrbd.block.Group.shifts","title":"<code>shifts</code>  <code>property</code>","text":"<p>List of vertical position shifts for each <code>Block</code> instance in group.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list of vertical position shifts for each <code>Block</code> instance in group</p>"},{"location":"reference/block.html#pyrbd.block.Group.arrow","title":"<code>arrow(connector_position)</code>","text":"<p>Get TikZ arrow string.</p> <p>Parameters:</p> Name Type Description Default <code>connector_position</code> <code>float</code> <p>distance in cm to right angle bend in connector (not used in <code>Group</code> class)</p> required <p>Returns:</p> Type Description <code>str</code> <p>TikZ string for arrow from <code>parent</code> to <code>self</code> or empty string if <code>parent</code> is <code>None</code></p> Source code in <code>pyrbd/block.py</code> <pre><code>def arrow(self, connector_position: float) -&gt; str:\n    \"\"\"Get TikZ arrow string.\n\n    Parameters\n    ----------\n    connector_position : float\n        distance in cm to right angle bend in connector (not used in `Group` class)\n\n    Returns\n    -------\n    str\n        TikZ string for arrow from `parent` to `self` or empty string if `parent` is `None`\n    \"\"\"\n\n    if self.parent is None:\n        return \"\"\n\n    return f\"\\\\draw[{self.arrow_options}] ({self.parent.id}.east) to ({self.id}.west);\\n\"\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Group.get_node","title":"<code>get_node(connector_position=None)</code>","text":"<p>Get TikZ node string.</p> <p>Parameters:</p> Name Type Description Default <code>connector_position</code> <code>Optional[float]</code> <p>distance in cm to right angle bend in connector. Locked to 0.0 for <code>Group</code> class</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>TikZ string for rendering group</p> Source code in <code>pyrbd/block.py</code> <pre><code>def get_node(self, connector_position: Optional[float] = None) -&gt; str:\n    \"\"\"Get TikZ node string.\n\n    Parameters\n    ----------\n    connector_position : Optional[float]\n        distance in cm to right angle bend in connector.\n        Locked to 0.0 for `Group` class\n\n    Returns\n    -------\n    str\n        TikZ string for rendering group\n    \"\"\"\n\n    connector_position = 0.0\n\n    block_nodes = \"\\n\".join(\n        block.get_node(connector_position) for block in self.blocks\n    )\n\n    group_node = \"\".join(\n        [\n            \"%%% Group\\n\"\n            f\"\\\\node[anchor=west, outer sep=0pt, inner sep=0pt, align=center] ({self.id}) \",\n            self.position,\n            \"{\\\\begin{tikzpicture}\\n\",\n            f\"\\\\coordinate ({self.id}) at (0, 0);\\n\",\n            block_nodes,\n            self.arrows,\n            \"\\\\end{tikzpicture}};\\n\\n\",\n            self.arrow(connector_position),\n            self.background,\n            self.label,\n        ]\n    )\n\n    return group_node\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Series","title":"<code>Series</code>","text":"<p>               Bases: <code>Block</code></p> <p>Series configuration of <code>Block</code> instances for horisontal grouping.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>list[Block]</code> <p>list of <code>Block</code> instances</p> required <code>text</code> <code>str</code> <p>series label text</p> <code>''</code> <code>color</code> <code>str</code> <p>series color, defaults to white</p> <code>''</code> <code>parent</code> <code>Optional[Block]</code> <p>parent <code>Block</code> instance</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>tikz_options</code> <code>str</code> <p>TikZ node options</p> <code>internal_arrow_length</code> <code>float</code> <p>distance between blocks in series</p> <code>pad</code> <code>Padding</code> <p><code>namedtuple</code> <code>(north, east, south, west)</code> defining padding (in mmm) between blocks and series frame</p> <code>label_height</code> <code>float</code> <p>height of series label (in mm)</p> Source code in <code>pyrbd/block.py</code> <pre><code>class Series(Block):\n    \"\"\"Series configuration of `Block` instances for horisontal grouping.\n\n    Parameters\n    ----------\n    blocks : list[Block]\n        list of `Block` instances\n    text: str, default=\"\"\n        series label text\n    color: str, default=\"\"\n        series color, defaults to white\n    parent : Optional[Block]\n        parent `Block` instance\n\n    Attributes\n    ----------\n    tikz_options : str\n        TikZ node options\n    internal_arrow_length : float\n        distance between blocks in series\n    pad : Padding\n        `namedtuple` `(north, east, south, west)` defining padding (in mmm) between\n        blocks and series frame\n    label_height : float\n        height of series label (in mm)\n\n    \"\"\"\n\n    tikz_options: str = \", \".join(\n        [\n            \"anchor=west\",\n            \"align=center\",\n            \"inner sep=0pt\",\n            \"outer sep=0pt\",\n        ]\n    )\n    internal_arrow_length: float = 0.3\n    pad: Padding = Padding(1, 1, 1, 2.5)\n    label_height: float = 5.0\n\n    def __init__(\n        self,\n        blocks: list[Block],\n        text: str = \"\",\n        color: str = \"\",\n        parent: Optional[Block] = None,\n    ) -&gt; None:\n        Block.__init__(self, text, color, parent)\n\n        self.blocks = blocks\n        self.blocks[0].id = f\"{self.id}+0\"\n        self.blocks[0].shift = (self.internal_arrow_length, 0)\n        for i, (block, new_parent) in enumerate(\n            zip(self.blocks[1::], self.blocks[0:-1]), start=1\n        ):\n            block.parent = new_parent\n            block.id = f\"{self.id}+{i}\"\n            block.arrow_length = self.internal_arrow_length\n\n    @property\n    def background(self) -&gt; str:\n        \"\"\"Background rectangle TikZ string.\"\"\"\n\n        if self.color in (\"white\", \"\"):\n            return \"\"\n\n        pad = self.pad\n\n        return \"\".join(\n            [\n                \"\\\\begin{pgfonlayer}{background}\\n\",\n                f\"\\\\coordinate (sw) at ($({self.id}.south west)+(-{pad.w}mm, -{pad.s}mm)$);\\n\",\n                f\"\\\\coordinate (ne) at ($({self.id}.north east)+({pad.e}mm, {pad.n}mm)$);\\n\",\n                f\"\\\\draw[{self.color}, thick] (sw) rectangle (ne);\\n\",\n                \"\\\\end{pgfonlayer}\\n\",\n            ]\n        )\n\n    @property\n    def label(self) -&gt; str:\n        \"\"\"Series label string.\"\"\"\n\n        if len(self.text) == 0:\n            return \"\"\n\n        pad = self.pad\n\n        return \"\".join(\n            [\n                f\"\\\\coordinate (nw) at ($({self.id}.north west)+(-{pad.w}mm, {pad.n}mm)$);\\n\",\n                f\"\\\\coordinate (ne) at ($({self.id}.north east)+({pad.e}mm, {pad.n}mm)$);\\n\",\n                \"\\\\coordinate (n) at \"\n                f\"($({self.id}.north)+(0mm, {self.label_height / 2 + pad.n}mm)$);\\n\",\n                f\"\\\\draw[{self.color}, fill={self.color}!50, thick] (nw) \",\n                f\"rectangle ($(ne)+(0, {self.label_height}mm)$);\\n\",\n                f\"\\\\node[anchor=center, inner sep=0pt, outer sep=0pt] at (n) {{{self.text}}};\\n\",\n            ]\n        )\n\n    def get_node(self, connector_position: Optional[float] = None) -&gt; str:\n        \"\"\"Get TikZ node string.\n\n        Parameters\n        ----------\n        connector_position : Optional[float]\n            distance in cm to right angle bend in connector. Defaults to `0.5 * arrow_length`\n\n        Returns\n        -------\n        str\n            TikZ string for rendering series\n\n        \"\"\"\n\n        if connector_position is None:\n            connector_position = self.arrow_length / 2\n\n        block_nodes = \"\\n\".join(\n            block.get_node(connector_position) for block in self.blocks\n        )\n        series_node = \"\".join(\n            [\n                f\"%%% Series\\n\\\\node[{self.tikz_options}]\",\n                f\"({self.id})\",\n                self.position,\n                \"{\\\\begin{tikzpicture}\\n\",\n                block_nodes,\n                \"\\\\end{tikzpicture}};\\n\\n\",\n                self.arrow(connector_position),\n                self.background,\n                self.label,\n            ]\n        )\n        return series_node\n\n    def get_blocks(self) -&gt; Generator[Block, None, None]:\n        yield from [\n            children for block in self.blocks for children in block.get_blocks()\n        ]\n</code></pre>"},{"location":"reference/block.html#pyrbd.block.Series.background","title":"<code>background</code>  <code>property</code>","text":"<p>Background rectangle TikZ string.</p>"},{"location":"reference/block.html#pyrbd.block.Series.label","title":"<code>label</code>  <code>property</code>","text":"<p>Series label string.</p>"},{"location":"reference/block.html#pyrbd.block.Series.get_node","title":"<code>get_node(connector_position=None)</code>","text":"<p>Get TikZ node string.</p> <p>Parameters:</p> Name Type Description Default <code>connector_position</code> <code>Optional[float]</code> <p>distance in cm to right angle bend in connector. Defaults to <code>0.5 * arrow_length</code></p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>TikZ string for rendering series</p> Source code in <code>pyrbd/block.py</code> <pre><code>def get_node(self, connector_position: Optional[float] = None) -&gt; str:\n    \"\"\"Get TikZ node string.\n\n    Parameters\n    ----------\n    connector_position : Optional[float]\n        distance in cm to right angle bend in connector. Defaults to `0.5 * arrow_length`\n\n    Returns\n    -------\n    str\n        TikZ string for rendering series\n\n    \"\"\"\n\n    if connector_position is None:\n        connector_position = self.arrow_length / 2\n\n    block_nodes = \"\\n\".join(\n        block.get_node(connector_position) for block in self.blocks\n    )\n    series_node = \"\".join(\n        [\n            f\"%%% Series\\n\\\\node[{self.tikz_options}]\",\n            f\"({self.id})\",\n            self.position,\n            \"{\\\\begin{tikzpicture}\\n\",\n            block_nodes,\n            \"\\\\end{tikzpicture}};\\n\\n\",\n            self.arrow(connector_position),\n            self.background,\n            self.label,\n        ]\n    )\n    return series_node\n</code></pre>"},{"location":"reference/config.html","title":"Config","text":""},{"location":"reference/config.html#pyrbd.config","title":"<code>config</code>","text":"<p>Module containing global configuration options.</p> <p>Attributes:</p> Name Type Description <code>ARROW_STYLE</code> <code>str</code> <p>definition of TikZ arrow style. Any style defined in the TikZ <code>arrows</code> library is valid, e.g. <code>'-&gt;'</code> and <code>'-latex'</code>. The default <code>''</code> gives a line without arrow head.</p> <code>SERIF_FONT</code> <code>bool</code> <p><code>False</code> to use sans-serif font (default), <code>True</code> to use serif fonts</p>"},{"location":"reference/diagram.html","title":"Diagram","text":""},{"location":"reference/diagram.html#pyrbd.diagram","title":"<code>diagram</code>","text":"<p>Module containing Diagram class definition.</p>"},{"location":"reference/diagram.html#pyrbd.diagram.Diagram","title":"<code>Diagram</code>","text":"<p>Reliability block diagram class definition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of diagram</p> required <code>blocks</code> <code>list[Block]</code> <p>list of <code>Block</code> instances</p> required <code>hazard</code> <code>str</code> <p>string defining the <code>hazard</code> block text</p> <code>''</code> <code>colors</code> <code>dict[str, str]</code> <p>dictionary with custom color definitions in HEX format: <code>{'color name': '6 digit hex code'}</code></p> <code>None</code> <p>Attributes:</p> Name Type Description <code>colors</code> <code>dict[str, str]</code> <p>default diagram color definitions</p> Source code in <code>pyrbd/diagram.py</code> <pre><code>class Diagram:\n    \"\"\"Reliability block diagram class definition.\n\n    Parameters\n    ----------\n    name : str\n        name of diagram\n    blocks : list[Block]\n        list of `Block` instances\n    hazard : str, optional\n        string defining the `hazard` block text\n    colors : dict[str, str], optional\n        dictionary with custom color definitions in HEX format:\n        `{'color name': '6 digit hex code'}`\n\n    Attributes\n    ----------\n    colors : dict[str, str]\n        default diagram color definitions\n    \"\"\"\n\n    colors: dict[str, str] = {\"arrowcolor\": \"4c4d4c\", \"hazardcolor\": \"ff6666\"}\n\n    def __init__(\n        self,\n        name: str,\n        blocks: list[Block],\n        hazard: str = \"\",\n        colors: Optional[dict[str, str]] = None,\n    ) -&gt; None:\n        self.filename = name\n        if hazard:\n            self.head = Block(hazard, \"hazardcolor\")\n        else:\n            self.head = blocks.pop(0)\n\n        self.head.id = \"0\"\n        self.blocks = blocks\n        self.blocks[0].parent = self.head\n\n        if colors is not None:\n            self.colors = self.colors | colors\n\n    def write(self) -&gt; None:\n        \"\"\"Write diagram to .tex file.\"\"\"\n\n        with open(f\"{self.filename}.tex\", mode=\"w\", encoding=\"utf-8\") as file:\n            file.write(_tex_preamble(self.colors))\n            for block in [self.head, *self.blocks]:\n                file.write(block.get_node())\n            file.write(TEX_END)\n\n    def _to_svg(self) -&gt; str:\n        \"\"\"Convert diagram file from pdf to svg.\n\n        Returns\n        -------\n        str\n            filename of .svg file\n        \"\"\"\n\n        pdf_document = pymupdf.open(f\"{self.filename}.pdf\")\n        page = pdf_document[0]\n\n        # Get and convert page to svg image\n        svg_content = page.get_svg_image().splitlines()\n        svg_content.insert(\n            1,\n            \"\\n\".join(\n                [\n                    \"&lt;style&gt;\",\n                    \"   @media (prefers-color-scheme: light) { :root { --color: #000000; } }\",\n                    \"   @media (prefers-color-scheme: dark) { :root { --color: #DDDDDD; } }\",\n                    \"&lt;/style&gt;\",\n                ]\n            ),\n        )\n        svg_content = \"\\n\".join(svg_content).replace(r\"#4c4d4c\", \"var(--color)\")\n\n        # Save to file\n        with open(output_file := f\"{self.filename}.svg\", \"w\", encoding=\"utf-8\") as file:\n            file.write(svg_content)\n\n        pdf_document.close()\n\n        return output_file\n\n    def _to_png(self) -&gt; str:\n        \"\"\"Convert diagram file from pdf to png.\n\n        Returns\n        -------\n        str\n            filename of .png file\n        \"\"\"\n\n        pdf_document = pymupdf.open(f\"{self.filename}.pdf\")\n        page = pdf_document[0]\n\n        # Get image\n        image = page.get_pixmap(dpi=300)  # type: ignore\n\n        # Save to file\n        image.save(output_file := f\"{self.filename}.png\")\n\n        pdf_document.close()\n\n        return output_file\n\n    def compile(\n        self, output: str | list[str] = \"pdf\", clear_source: bool = True\n    ) -&gt; list[str]:\n        \"\"\"Compile diagram .tex file.\n\n        Parameters\n        ----------\n        output : str | list[str], default='pdf'\n            output format string or list of output formats for diagram. Valid output formats are\n\n            - `'pdf'` (default)\n            - `'svg'`\n            - `'png'`\n\n        clear_source : bool, default=True\n            .tex source file is deleted after compilation if `True`\n\n        Returns\n        -------\n        list[str]\n            list of output filenames\n\n        Raises\n        ------\n        FileNotFoundError\n            If .tex file is not found, e.g. because `Diagram.write()` has not been called\n            before `Diagram.compile()`.\n        \"\"\"\n\n        try:\n            subprocess.check_call(\n                [\"latexmk\", \"--lualatex\", f\"{self.filename}.tex\", \"--silent\"]\n            )\n            subprocess.check_call([\"latexmk\", \"-c\", f\"{self.filename}.tex\"])\n            if clear_source:\n                subprocess.check_call([\"rm\", f\"{self.filename}.tex\"])\n        except subprocess.CalledProcessError as err:\n            if err.returncode == 11:\n                raise FileNotFoundError(\n                    (\n                        f\"File {self.filename} not found. \"\n                        + \"Check if call to Class method write() is missing.\"\n                    )\n                ) from err\n\n        output_files: list[str] = []\n\n        if not isinstance(output, list):\n            output = [output]\n\n        if \"svg\" in output:\n            output_files.append(self._to_svg())\n        if \"png\" in output:\n            output_files.append(self._to_png())\n        if \"pdf\" not in output:\n            subprocess.check_call([\"rm\", f\"{self.filename}.pdf\"])\n        else:\n            output_files.append(f\"{self.filename}.pdf\")\n\n        return output_files\n</code></pre>"},{"location":"reference/diagram.html#pyrbd.diagram.Diagram.compile","title":"<code>compile(output='pdf', clear_source=True)</code>","text":"<p>Compile diagram .tex file.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str | list[str]</code> <p>output format string or list of output formats for diagram. Valid output formats are</p> <ul> <li><code>'pdf'</code> (default)</li> <li><code>'svg'</code></li> <li><code>'png'</code></li> </ul> <code>'pdf'</code> <code>clear_source</code> <code>bool</code> <p>.tex source file is deleted after compilation if <code>True</code></p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of output filenames</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If .tex file is not found, e.g. because <code>Diagram.write()</code> has not been called before <code>Diagram.compile()</code>.</p> Source code in <code>pyrbd/diagram.py</code> <pre><code>def compile(\n    self, output: str | list[str] = \"pdf\", clear_source: bool = True\n) -&gt; list[str]:\n    \"\"\"Compile diagram .tex file.\n\n    Parameters\n    ----------\n    output : str | list[str], default='pdf'\n        output format string or list of output formats for diagram. Valid output formats are\n\n        - `'pdf'` (default)\n        - `'svg'`\n        - `'png'`\n\n    clear_source : bool, default=True\n        .tex source file is deleted after compilation if `True`\n\n    Returns\n    -------\n    list[str]\n        list of output filenames\n\n    Raises\n    ------\n    FileNotFoundError\n        If .tex file is not found, e.g. because `Diagram.write()` has not been called\n        before `Diagram.compile()`.\n    \"\"\"\n\n    try:\n        subprocess.check_call(\n            [\"latexmk\", \"--lualatex\", f\"{self.filename}.tex\", \"--silent\"]\n        )\n        subprocess.check_call([\"latexmk\", \"-c\", f\"{self.filename}.tex\"])\n        if clear_source:\n            subprocess.check_call([\"rm\", f\"{self.filename}.tex\"])\n    except subprocess.CalledProcessError as err:\n        if err.returncode == 11:\n            raise FileNotFoundError(\n                (\n                    f\"File {self.filename} not found. \"\n                    + \"Check if call to Class method write() is missing.\"\n                )\n            ) from err\n\n    output_files: list[str] = []\n\n    if not isinstance(output, list):\n        output = [output]\n\n    if \"svg\" in output:\n        output_files.append(self._to_svg())\n    if \"png\" in output:\n        output_files.append(self._to_png())\n    if \"pdf\" not in output:\n        subprocess.check_call([\"rm\", f\"{self.filename}.pdf\"])\n    else:\n        output_files.append(f\"{self.filename}.pdf\")\n\n    return output_files\n</code></pre>"},{"location":"reference/diagram.html#pyrbd.diagram.Diagram.write","title":"<code>write()</code>","text":"<p>Write diagram to .tex file.</p> Source code in <code>pyrbd/diagram.py</code> <pre><code>def write(self) -&gt; None:\n    \"\"\"Write diagram to .tex file.\"\"\"\n\n    with open(f\"{self.filename}.tex\", mode=\"w\", encoding=\"utf-8\") as file:\n        file.write(_tex_preamble(self.colors))\n        for block in [self.head, *self.blocks]:\n            file.write(block.get_node())\n        file.write(TEX_END)\n</code></pre>"}]}